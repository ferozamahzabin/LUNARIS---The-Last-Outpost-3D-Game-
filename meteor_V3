# lunaris_merged.py
# Merged: LUNARIS meteor shooter + 3D cratered moon visuals
from OpenGL.GL import *
from OpenGL.GLUT import *
from OpenGL.GLU import *
import math, random, time

# ---------------------------
# Window
# ---------------------------
WIDTH, HEIGHT = 1000, 800
random.seed(423)

# ---------------------------
# Moon / world scale (from moon sample)
# ---------------------------
BASE_RADIUS = 1500            # large world radius (sphere)
SURFACE_RADIUS = BASE_RADIUS / 4  # radius used for gameplay (comparable to old BASE_RADIUS)
NUM_CRATERS = 20
craters = []

# Stars (3D)
NUM_STARS = 300
stars = []

# ---------------------------
# Player / Game state
# ---------------------------
player_pos = [0.0, 0.0, SURFACE_RADIUS + 20.0]  # stand on moon surface
gun_angle = 45.0
PLAYER_SPEED = 10.0

# player energy / lives
energy = 100.0
max_energy = 100.0
hit_count = 0
MAX_HITS = 10

# Game state
game_over = False

# Umbrella
umbrella_active = False
umbrella_energy_cost = 0.5  # energy consumed per update while active

# First-person toggle
first_person_mode = False

# Score & level
score = 0
level = 1
SCORE_PER_LEVEL = 50

# Camera (third-person orbit)
camera_angle = 45.0
camera_height = 150.0
camera_radius = 520.0
camera_pos = [camera_radius, 0.0, camera_height]

# Meteors
meteors = []   # each: {"x","y","z","vx","vy","vz","r","is_hit","hit_timer"}
last_spawn_time = 0.0
storm_intensity = 1.0

# Bullets
bullets = []   # each: {'pos':[x,y,z],'vel':[vx,vy,vz],'active':True}
BULLET_SPEED = 50.0
BULLET_SIZE = 20.0
BULLET_COOLDOWN_MS = 120
last_shot_time = -100000

# Targeted intercept
TARGET_COOLDOWN = 0.3
last_target_time = 0.0
TARGET_SCORE = 10
ENERGY_RESTORE = 6

# Visual constants (player model)
HEAD_R = 21
TORSO_W, TORSO_D, TORSO_H = 33.0, 21.0, 57.0
SHOULDER_R = 7.5
ARM_R, ARM_L = 6.0, 33.0
LEG_R_TOP, LEG_R_BOT, LEG_L = 10.5, 6.75, 42.0
GUN_BODY_L, GUN_BODY_W, GUN_BODY_H = 18.0, 8.0, 7.0
GUN_BARREL_R, GUN_BARREL_L = 3.0, 15.0

# Timing
FRAME_DT = 1.0 / 60.0

# ---------------------------
# Stars & moon functions (from moon sample)
# ---------------------------
def generate_stars(count=NUM_STARS):
    global stars
    stars = []
    for _ in range(count):
        theta = random.uniform(0, 2 * math.pi)
        phi = random.uniform(-math.pi / 2, math.pi / 2)
        radius = random.uniform(1200, 2500)
        x = radius * math.cos(phi) * math.cos(theta)
        y = radius * math.cos(phi) * math.sin(theta)
        z = radius * math.sin(phi)
        stars.append((x, y, z))

def draw_stars():
    glPointSize(2)
    glBegin(GL_POINTS)
    for i, (x, y, z) in enumerate(stars):
        # Slight blinking
        blink_speed = 200.0 + (i % 3) * 50
        brightness = 0.6 + 0.4 * math.sin(glutGet(GLUT_ELAPSED_TIME) / blink_speed + i)
        glColor3f(brightness, brightness, brightness)
        glVertex3f(x, y, z)
    glEnd()

def init_craters():
    global craters
    craters = []
    moon_radius = SURFACE_RADIUS
    SAFE_ZONE_RADIUS = 200.0
    # Fill until we have NUM_CRATERS (skip craters inside safe origin)
    attempts = 0
    while len(craters) < NUM_CRATERS and attempts < NUM_CRATERS * 6:
        attempts += 1
        theta = random.uniform(0, 2 * math.pi)
        phi = random.uniform(0, math.pi)
        x = moon_radius * math.sin(phi) * math.cos(theta)
        y = moon_radius * math.sin(phi) * math.sin(theta)
        z = moon_radius * math.cos(phi)
        if math.hypot(x, y) < SAFE_ZONE_RADIUS:
            continue
        r = random.uniform(20, 50)
        craters.append({'pos': [x, y, z], 'radius': r})

def draw_moon():
    # main sphere
    glPushMatrix()
    glColor3f(0.7, 0.7, 0.7)
    glutSolidSphere(SURFACE_RADIUS, 60, 60)
    glPopMatrix()
    # craters (sunken spheres oriented correctly)
    for crater in craters:
        crater_pos = crater['pos']
        crater_radius = crater['radius']
        glPushMatrix()
        glColor3f(0.42, 0.42, 0.45)
        glTranslatef(crater_pos[0], crater_pos[1], crater_pos[2])
        dx, dy, dz = crater_pos
        angle_xy = math.degrees(math.atan2(dy, dx))
        # Protect against divide by zero for angle_z:
        hypot_xy = math.sqrt(dx*dx + dy*dy)
        angle_z = math.degrees(math.atan2(hypot_xy, dz)) if dz != 0 else 0.0
        glRotatef(angle_xy, 0, 0, 1)
        glRotatef(angle_z, 0, 1, 0)
        glTranslatef(0, 0, -2)
        glutSolidSphere(crater_radius, 20, 20)
        glPopMatrix()

# ---------------------------
# Utility / HUD & crosshair
# ---------------------------
def draw_text(x, y, text, rgb=(1,1,1), font=GLUT_BITMAP_HELVETICA_18):
    glColor3f(*rgb)
    glMatrixMode(GL_PROJECTION)
    glPushMatrix()
    glLoadIdentity()
    gluOrtho2D(0, WIDTH, 0, HEIGHT)
    glMatrixMode(GL_MODELVIEW)
    glPushMatrix()
    glLoadIdentity()
    glRasterPos2f(x, y)
    for ch in text:
        glutBitmapCharacter(font, ord(ch))
    glPopMatrix()
    glMatrixMode(GL_PROJECTION)
    glPopMatrix()
    glMatrixMode(GL_MODELVIEW)

def draw_targeting_reticle():
    glMatrixMode(GL_PROJECTION)
    glPushMatrix()
    glLoadIdentity()
    gluOrtho2D(0, WIDTH, 0, HEIGHT)
    glMatrixMode(GL_MODELVIEW)
    glPushMatrix()
    glLoadIdentity()
    glColor3f(1.0, 0.0, 0.0)
    glLineWidth(2.0)
    cx, cy = WIDTH/2, HEIGHT/2
    glBegin(GL_LINES)
    glVertex2f(cx - 12, cy)
    glVertex2f(cx + 12, cy)
    glVertex2f(cx, cy - 12)
    glVertex2f(cx, cy + 12)
    glEnd()
    glLineWidth(1.0)
    glPopMatrix()
    glMatrixMode(GL_PROJECTION)
    glPopMatrix()
    glMatrixMode(GL_MODELVIEW)

def get_level_name(lvl):
    if lvl <= 2: return 'EASY'
    if lvl <= 5: return 'MEDIUM'
    if lvl <= 8: return 'HARD'
    return 'EXTREME'

def draw_hud():
    lives_left = max(0, MAX_HITS - hit_count)
    level_name = get_level_name(level)
    draw_text(18, HEIGHT - 40, f"SCORE:{score:04d}   LEVEL:{level}({level_name})   LIVES:{lives_left}")
    e_int = max(0, int(energy))
    energy_percent = energy / max_energy if max_energy > 0 else 0
    energy_color = (1.0,1.0,1.0) if energy_percent>0.5 else (1.0,0.6,0.4) if energy_percent>0.2 else (1.0,0.3,0.3)
    draw_text(18, HEIGHT - 64, f"ENERGY:{e_int:03d}", rgb=energy_color)
    next_level = level * SCORE_PER_LEVEL
    remaining = next_level - score
    if remaining > 0:
        draw_text(18, HEIGHT - 88, f"Next Level: {remaining} pts", rgb=(0.8,0.8,0.8))
    if umbrella_active:
        draw_text(WIDTH - 240, HEIGHT - 40, "â˜‚ UMBRELLA ACTIVE", rgb=(0.95,0.95,0.2))

# ---------------------------
# Umbrella (3D hemisphere + handle)
# ---------------------------
def draw_umbrella():
    if not umbrella_active:
        return
    px, py, pz = player_pos
    canopy_height = pz + TORSO_H + HEAD_R * 0.2 + 6.0
    canopy_radius = max(TORSO_W, TORSO_D) * 1.8
    energy_factor = max(0.35, min(1.0, energy / max_energy))

    glColor3f(0.85 * energy_factor, 0.15, 0.2 * energy_factor)
    quad = gluNewQuadric()

    # Canopy (flattened sphere; we draw a full sphere scaled in Z, but visually it's a hemisphere placed above head)
    glPushMatrix()
    glTranslatef(px, py, canopy_height)
    glPushMatrix()
    glScalef(1.0, 1.0, 0.55)     # squash vertically -> umbrella shape
    gluSphere(quad, canopy_radius, 28, 12)
    glPopMatrix()
    glPopMatrix()

    # Handle (thin cylinder from canopy down through player)
    glColor3f(0.45, 0.33, 0.2)
    glPushMatrix()
    glTranslatef(px, py, canopy_height)
    glRotatef(-90, 1, 0, 0)   # align cylinder along -Z
    # length roughly canopy_height - (player_pos[2] - small offset)
    length = canopy_height - (pz - 10.0)
    if length < 1.0: length = 1.0
    gluCylinder(quad, 2.5, 2.5, length, 12, 1)
    glPopMatrix()

# ---------------------------
# Player drawing (TPV full body, FPV partial)
# ---------------------------
def draw_player():
    glPushMatrix()
    # Place player on moon surface (translate to player_pos)
    glTranslatef(player_pos[0], player_pos[1], player_pos[2])
    # Rotate to face gun_angle (Z-up world)
    glRotatef(gun_angle, 0, 0, 1)

    if first_person_mode:
        # Draw small chest and gun (so FPV sees a bit of model)
        # Gun
        glPushMatrix()
        glTranslatef(TORSO_W * 0.6, 0, TORSO_H * 0.72)
        glColor3f(0.22, 0.22, 0.22)
        glPushMatrix()
        glTranslatef(GUN_BODY_L * 0.5, 0, 0)
        glScalef(GUN_BODY_L, GUN_BODY_W, GUN_BODY_H)
        glutSolidCube(1.0)
        glPopMatrix()
        glColor3f(0.85, 0.0, 0.0)
        glRotatef(90, 0, 1, 0)
        quad = gluNewQuadric()
        gluCylinder(quad, GUN_BARREL_R, GUN_BARREL_R, GUN_BARREL_L, 20, 1)
        glPopMatrix()
        # small chest
        glPushMatrix()
        glTranslatef(0, 0, TORSO_H*0.42)
        glScalef(TORSO_W*0.5, TORSO_D*0.5, TORSO_H*0.45)
        glColor3f(0.4, 0.65, 0.4)
        glutSolidCube(1.0)
        glPopMatrix()
    else:
        # Full body
        # torso
        glColor3f(0.4, 0.65, 0.4)
        glPushMatrix()
        glTranslatef(0,0, TORSO_H/2.0)
        glScalef(TORSO_W, TORSO_D, TORSO_H)
        glutSolidCube(1.0)
        glPopMatrix()
        # head (now same as arm color)
        glColor3f(0.9, 0.8, 0.7)   # same as arms
        glPushMatrix()
        glTranslatef(0, 0, TORSO_H + HEAD_R)
        glutSolidSphere(HEAD_R, 20, 20)
        glPopMatrix()
        # shoulders & arms
        glColor3f(0.9,0.8,0.7)
        for side in (-1,1):
            glPushMatrix()
            glTranslatef(0, side*(TORSO_D/2.0 + SHOULDER_R*0.3), TORSO_H*0.74)
            glutSolidSphere(SHOULDER_R, 12,12)
            glPopMatrix()
            glPushMatrix()
            glTranslatef(0, side*(TORSO_D/2.0 + 1.0), TORSO_H*0.74)
            glRotatef(90,0,1,0)
            quad = gluNewQuadric()
            gluCylinder(quad, ARM_R, ARM_R, ARM_L, 12,1)
            glPopMatrix()
        # legs (now red)
        glColor3f(1.0, 0.0, 0.0)  # red legs
        leg_width = 12.0
        leg_depth = 12.0
        leg_height = player_pos[2]  # calculate actual vertical offset
        # We know torso base starts at z=0 (since we translate player to player_pos already)
        # So to make legs touch the moon, we just drop them from torso down to z=0.
        for side in (-1, 1):
            glPushMatrix()
            glTranslatef(side * (TORSO_W * 0.25), 0, -(LEG_L / 2.0))  # drop half down
            glScalef(leg_width, leg_depth, LEG_L)   # shape of legs
            glutSolidCube(1.0)
            glPopMatrix()
        # gun visible in TPV
        glPushMatrix()
        glTranslatef(TORSO_W*0.6, 0, TORSO_H*0.72)
        glColor3f(0.22, 0.22, 0.22)
        glPushMatrix()
        glTranslatef(GUN_BODY_L*0.5, 0, 0)
        glScalef(GUN_BODY_L, GUN_BODY_W, GUN_BODY_H)
        glutSolidCube(1.0)
        glPopMatrix()
        glColor3f(0.85,0.0,0.0)
        glRotatef(90,0,1,0)
        quad = gluNewQuadric()
        gluCylinder(quad, GUN_BARREL_R, GUN_BARREL_R, GUN_BARREL_L, 20,1)
        glPopMatrix()

    # Umbrella above head
    draw_umbrella()
    glPopMatrix()


# ---------------------------
# Meteors spawn & update (kept from your logic)
# ---------------------------
def get_storm_parameters(lvl):
    base_interval = max(0.3, 1.8 - (lvl * 0.15))
    meteors_per_wave = min(16, 2 + lvl)
    base_speed = min(28.0, 8.0 + (lvl * 1.5))
    storm_variance = 0.25 + (lvl * 0.04)
    return base_interval, meteors_per_wave, base_speed, storm_variance

def calculate_dynamic_spawn_interval(lvl):
    base_interval, _, _, variance = get_storm_parameters(lvl)
    random_factor = random.uniform(1.0 - variance, 1.0 + variance)
    return base_interval * random_factor * storm_intensity

def spawn_meteor_storm():
    global storm_intensity
    _, count, base_speed, _ = get_storm_parameters(level)
    if level >= 3 and random.random() < 0.18:
        count = int(count * 1.4)
        storm_intensity = min(2.0, storm_intensity * 1.1)
    for _ in range(count):
        ang = random.uniform(0, 2*math.pi)
        # spawn horizontally around origin within surface radius
        dist = random.uniform(50, SURFACE_RADIUS - 50)
        x = dist * math.cos(ang)
        y = dist * math.sin(ang)
        z = random.uniform(350, 900)
        vx = random.uniform(-1.2, 1.2)
        vy = random.uniform(-1.2, 1.2)
        vz = -random.uniform(base_speed * 0.8, base_speed * 1.1)
        r = random.uniform(10, 34) if level <= 3 else random.uniform(9, 28)
        meteors.append({"x":x,"y":y,"z":z,"vx":vx,"vy":vy,"vz":vz,"r":r,"is_hit":False,"hit_timer":0.0})

def update_meteors_and_collisions():
    global meteors, score, hit_count, energy, game_over
    new_meteors = []
    for m in meteors:
        if not m["is_hit"]:
            m["x"] += m["vx"]
            m["y"] += m["vy"]
            m["z"] += m["vz"]
        else:
            m["hit_timer"] += FRAME_DT
            m["x"] += m["vx"]*0.15
            m["y"] += m["vy"]*0.15
            m["z"] += m["vz"]*0.15

        # reached ground (z <= 0 surface plane)
        if m["z"] <= 0:
            # check umbrella block
            if umbrella_active:
                px,py,pz = player_pos
                canopy_z = pz + TORSO_H + HEAD_R * 0.2 + 6.0
                dx = m["x"] - px; dy = m["y"] - py; dz = 0 - canopy_z
                horiz = math.hypot(dx, dy)
                if horiz <= max(TORSO_W, TORSO_D) * 1.0 and abs(dz) <= 30:
                    # blocked by umbrella
                    continue
            dx = m["x"] - player_pos[0]; dy = m["y"] - player_pos[1]
            horiz = math.hypot(dx, dy)
            if horiz < (m["r"] + 18):
                hit_count += 1
                energy -= 15
                score = max(0, score - 8)
                if hit_count >= MAX_HITS or energy <= 0:
                    game_over = True
            continue

        # destruction flicker
        if m["is_hit"]:
            if m["hit_timer"] >= 0.45:
                continue
            new_meteors.append(m)
            continue

        # check bullets
        collided = False
        for b in bullets[:]:
            dx = m["x"] - b['pos'][0]; dy = m["y"] - b['pos'][1]; dz = m["z"] - b['pos'][2]
            dist3 = math.sqrt(dx*dx + dy*dy + dz*dz)
            if dist3 <= (m["r"] + 3.0):
                m["is_hit"] = True
                m["hit_timer"] = 0.0
                try:
                    bullets.remove(b)
                except ValueError:
                    pass
                score += 1
                energy = min(max_energy, energy + 1.0)
                collided = True
                break
        if collided:
            new_meteors.append(m)
            continue

        # collision with umbrella mid-air
        if umbrella_active:
            px,py,pz = player_pos
            canopy_z = pz + TORSO_H + HEAD_R * 0.2 + 6.0
            dx = m["x"] - px; dy = m["y"] - py; dz = m["z"] - canopy_z
            horiz = math.hypot(dx, dy)
            if horiz <= max(TORSO_W, TORSO_D) * 1.0 and abs(dz) <= 25 and m["vz"] < 0:
                continue

        # low near player direct hit
        dx = m["x"] - player_pos[0]; dy = m["y"] - player_pos[1]
        horiz = math.hypot(dx, dy)
        if horiz < (m["r"] + 15) and m["z"] <= 30:
            hit_count += 1
            energy -= 15
            score = max(0, score - 8)
            if hit_count >= MAX_HITS or energy <= 0:
                game_over = True
            continue

        new_meteors.append(m)
    meteors = new_meteors

def draw_meteors():
    for m in meteors:
        glPushMatrix()
        glTranslatef(m["x"], m["y"], m["z"])
        if m["is_hit"]:
            if int(m["hit_timer"] * 25) % 2 == 0:
                glColor3f(1.0, 0.9, 0.5)
                glutSolidSphere(m["r"]*1.1, 12, 12)
        else:
            intensity = min(1.0, 0.5 + (level*0.04))
            glColor3f(1.0, intensity*0.6, intensity*0.1)
            glutSolidSphere(m["r"], 14, 14)
        glPopMatrix()

# ---------------------------
# Bullets (spawn from gun tip), update, draw
# ---------------------------
def get_gun_tip_world():
    # Compute gun tip position relative to player_pos and gun_angle
    forward = TORSO_W * 0.6 + GUN_BODY_L + GUN_BARREL_L * 0.5
    up = TORSO_H * 0.72
    gx = player_pos[0] + forward * math.cos(math.radians(gun_angle))
    gy = player_pos[1] + forward * math.sin(math.radians(gun_angle))
    gz = player_pos[2] + up
    return gx, gy, gz

def fire_bullet():
    global last_shot_time
    if game_over: return
    now = glutGet(GLUT_ELAPSED_TIME)
    if now - last_shot_time < BULLET_COOLDOWN_MS:
        return
    last_shot_time = now
    vx = math.cos(math.radians(gun_angle)) * BULLET_SPEED
    vy = math.sin(math.radians(gun_angle)) * BULLET_SPEED
    gun_x, gun_y, gun_z = get_gun_tip_world()
    bullets.append({'pos':[gun_x, gun_y, gun_z], 'vel':[vx,vy,0.0], 'active':True})

def update_bullets():
    for b in bullets[:]:
        b['pos'][0] += b['vel'][0] * (FRAME_DT*60.0)
        b['pos'][1] += b['vel'][1] * (FRAME_DT*60.0)
        # remove if out of arena bounds
        if abs(b['pos'][0]) > SURFACE_RADIUS + 800 or abs(b['pos'][1]) > SURFACE_RADIUS + 800:
            try:
                bullets.remove(b)
            except ValueError:
                pass

def draw_bullet(b):
    glPushMatrix()
    glTranslatef(b['pos'][0], b['pos'][1], b['pos'][2])
    glColor3f(1.0, 0.6, 0.1)
    glutSolidSphere(BULLET_SIZE*0.25, 8, 8)
    glPopMatrix()

# ---------------------------
# Targeted destroy (space)
# ---------------------------
def find_nearest_meteor():
    if not meteors: return None
    px,py,pz = player_pos
    nearest = None; md = float('inf')
    for m in meteors:
        if m["is_hit"]: continue
        dx = m["x"]-px; dy = m["y"]-py; dz = m["z"]-pz
        d = math.sqrt(dx*dx + dy*dy + dz*dz)
        if d < md:
            md = d; nearest = m
    return nearest

def target_and_destroy_meteor():
    global score, energy
    t = find_nearest_meteor()
    if t is None: return False
    t["is_hit"] = True
    t["hit_timer"] = 0.0
    score += TARGET_SCORE
    energy = min(max_energy, energy + ENERGY_RESTORE)
    return True

# ---------------------------
# Camera & input handlers
# ---------------------------
def setupCamera():
    glMatrixMode(GL_PROJECTION)
    glLoadIdentity()
    gluPerspective(110, WIDTH/float(HEIGHT), 0.1, 5000)
    glMatrixMode(GL_MODELVIEW)
    glLoadIdentity()
    if first_person_mode:
        # eye slightly above chest and slightly forward so we don't clip model
        eye_x = player_pos[0] + 8.0*math.cos(math.radians(gun_angle))
        eye_y = player_pos[1] + 8.0*math.sin(math.radians(gun_angle))
        eye_z = player_pos[2] + TORSO_H * 0.92
        at_x = eye_x + 200.0 * math.cos(math.radians(gun_angle))
        at_y = eye_y + 200.0 * math.sin(math.radians(gun_angle))
        at_z = eye_z
        gluLookAt(eye_x, eye_y, eye_z, at_x, at_y, at_z, 0, 0, 1)
    else:
        x = camera_pos[0]
        y = camera_pos[1]
        z = camera_pos[2]
        gluLookAt(x, y, z, 0.0, 0.0, SURFACE_RADIUS*0.18, 0, 0, 1)

def keyboardListener(key, x, y):
    global gun_angle, player_pos, umbrella_active, last_target_time, game_over
    if game_over and key not in (b'\r', b'\x1b'):
        return
    if key == b'a':
        gun_angle = (gun_angle + 6) % 360
    elif key == b'd':
        gun_angle = (gun_angle - 6) % 360
    elif key == b'w':
        nx = player_pos[0] + math.cos(math.radians(gun_angle))*PLAYER_SPEED
        ny = player_pos[1] + math.sin(math.radians(gun_angle))*PLAYER_SPEED
        if math.hypot(nx, ny) <= SURFACE_RADIUS - 18:
            player_pos[0], player_pos[1] = nx, ny
    elif key == b's':
        nx = player_pos[0] - math.cos(math.radians(gun_angle))*PLAYER_SPEED
        ny = player_pos[1] - math.sin(math.radians(gun_angle))*PLAYER_SPEED
        if math.hypot(nx, ny) <= SURFACE_RADIUS - 18:
            player_pos[0], player_pos[1] = nx, ny
    elif key == b'u':
        umbrella_active = not umbrella_active
    elif key == b' ':
        now = time.time()
        if now - last_target_time >= TARGET_COOLDOWN:
            target_and_destroy_meteor()
            last_target_time = now
    elif key == b'\r' and game_over:
        restart()
    elif key == b'\x1b':
        glutLeaveMainLoop()

def specialKeyListener(key, x, y):
    global camera_angle, camera_height, camera_pos
    if key == GLUT_KEY_UP:
        camera_height = min(900.0, camera_height + 20.0)
    elif key == GLUT_KEY_DOWN:
        camera_height = max(120.0, camera_height - 20.0)
    elif key == GLUT_KEY_LEFT:
        camera_angle = (camera_angle + 4.0) % 360.0
    elif key == GLUT_KEY_RIGHT:
        camera_angle = (camera_angle - 4.0) % 360.0
    dist = camera_radius
    camera_pos[0] = dist * math.cos(math.radians(camera_angle))
    camera_pos[1] = dist * math.sin(math.radians(camera_angle))
    camera_pos[2] = camera_height

def mouseListener(button, state, x, y):
    global first_person_mode
    if button == GLUT_LEFT_BUTTON and state == GLUT_DOWN and not game_over:
        fire_bullet()
    elif button == GLUT_RIGHT_BUTTON and state == GLUT_DOWN:
        first_person_mode = not first_person_mode

# ---------------------------
# Game loop: updates & draw
# ---------------------------
def update_umbrella_energy():
    global energy, game_over
    if umbrella_active:
        energy -= umbrella_energy_cost
        if energy <= 0:
            energy = 0
            game_over = True

def check_level_progression():
    global level, storm_intensity
    target_score = level * SCORE_PER_LEVEL
    if score >= target_score:
        level += 1
        storm_intensity = 1.0
        return True
    return False

def idle():
    global last_spawn_time
    if game_over:
        glutPostRedisplay()
        return
    now = time.time()
    if not hasattr(idle, 'next_spawn_interval'):
        idle.next_spawn_interval = calculate_dynamic_spawn_interval(level)
    if now - last_spawn_time >= idle.next_spawn_interval:
        spawn_meteor_storm()
        last_spawn_time = now
        idle.next_spawn_interval = calculate_dynamic_spawn_interval(level)
    update_bullets()
    update_meteors_and_collisions()
    update_umbrella_energy()
    check_level_progression()
    glutPostRedisplay()
    time.sleep(max(0.0, FRAME_DT - 0.002))

def draw_game_over():
    draw_text(WIDTH/2 - 120, HEIGHT/2 + 20, "GAME OVER - You Died!", rgb=(1,0.3,0.3))
    draw_text(WIDTH/2 - 140, HEIGHT/2 - 10, f"Final Score: {score} | Level: {level}", rgb=(1,1,1), font=GLUT_BITMAP_HELVETICA_12)
    draw_text(WIDTH/2 - 90, HEIGHT/2 - 40, "Press ENTER to restart", rgb=(0.9,0.9,0.9), font=GLUT_BITMAP_HELVETICA_12)

# ---------------------------
# Draw frame
# ---------------------------
def showScreen():
    glClear(GL_COLOR_BUFFER_BIT | GL_DEPTH_BUFFER_BIT)
    glLoadIdentity()
    glClearColor(0.01, 0.01, 0.03, 1)  # dark space background
    setupCamera()
    # background elements
    draw_stars()
    draw_moon()
    # gameplay objects
    draw_meteors()
    for b in bullets:
        draw_bullet(b)
    draw_player()
    draw_targeting_reticle()
    draw_hud()
    if game_over:
        draw_game_over()
    glutSwapBuffers()

# ---------------------------
# Restart & main
# ---------------------------
def restart():
    global energy, max_energy, score, level, game_over, meteors, bullets, player_pos, gun_angle, hit_count, umbrella_active, storm_intensity, last_spawn_time
    energy = 100.0
    max_energy = 100.0
    score = 0
    level = 1
    game_over = False
    meteors = []
    bullets = []
    player_pos = [0.0, 0.0, SURFACE_RADIUS + 20.0]
    gun_angle = 45.0
    hit_count = 0
    umbrella_active = False
    storm_intensity = 1.0
    last_spawn_time = time.time()
    if hasattr(idle, 'next_spawn_interval'):
        delattr(idle, 'next_spawn_interval')

def main():
    glutInit()
    glutInitDisplayMode(GLUT_DOUBLE | GLUT_RGB | GLUT_DEPTH)
    glutInitWindowSize(WIDTH, HEIGHT)
    glutInitWindowPosition(40, 40)
    glutCreateWindow(b"LUNARIS - Meteor Outpost (Merged Moon)")
    glEnable(GL_DEPTH_TEST)
    generate_stars(NUM_STARS)
    init_craters()
    glutDisplayFunc(showScreen)
    glutKeyboardFunc(keyboardListener)
    glutSpecialFunc(specialKeyListener)
    glutMouseFunc(mouseListener)
    glutIdleFunc(idle)
    glutMainLoop()

if __name__ == "__main__":
    main()
