from OpenGL.GL import *
from OpenGL.GLUT import *
from OpenGL.GLU import *
import math, random, time

# =========================
# Game State & globals
# =========================



random.seed(423)
energy = 100
score = 0
difficulty = 1           # 1,2,3
umbrella_active = False
game_over = False
first_person_mode = False

hit_count = 0
MAX_HITS = 10

# Camera
camera_angle = 45.0
camera_height = 150.0
camera_radius = 520.0
camera_pos = [camera_radius, 0.0, camera_height]

# Moon base / craters
BASE_RADIUS = 520
NUM_CRATERS = 32
craters = []

# Player constants & state
player_pos = [0.0, 0.0, 20.0]
gun_angle = 45.0
PLAYER_SPEED = 10.0

HEAD_R = 21
TORSO_W, TORSO_D, TORSO_H = 33.0, 21.0, 57.0
SHOULDER_R = 7.5
ARM_R, ARM_L = 6.0, 33.0
LEG_R_TOP, LEG_R_BOT, LEG_L = 10.5, 6.75, 42.0

# Meteors
meteors = []
last_spawn_time = 0.0

# Laser system
lasers = []          # each: {"x","y","z","life"}
LASER_SPEED = 160.0  # fast projectile
LASER_LENGTH = 70.0
LASER_COOLDOWN = 0.06   # quick shooting
last_laser_time = 0.0
LASER_SCORE = 2

# Stars (blinking)
stars = []
NUM_STARS = 140
for _ in range(NUM_STARS):
    stars.append({
        "x": random.uniform(-2000, 2000),
        "y": random.uniform(-2000, 2000),
        "z": random.uniform(400, 1800),
        "phase": random.uniform(0, 2 * math.pi)
    })

# Frame timing
FRAME_DT = 1.0 / 60.0

# =========================
# Utility / HUD
# =========================
def draw_text(x, y, text, font=GLUT_BITMAP_HELVETICA_18, rgb=(1,1,1)):
    glColor3f(*rgb)
    glMatrixMode(GL_PROJECTION)
    glPushMatrix()
    glLoadIdentity()
    gluOrtho2D(0, 1000, 0, 800)
    glMatrixMode(GL_MODELVIEW)
    glPushMatrix()
    glLoadIdentity()
    glRasterPos2f(x, y)
    for ch in text:
        glutBitmapCharacter(font, ord(ch))
    glPopMatrix()
    glMatrixMode(GL_PROJECTION)
    glPopMatrix()
    glMatrixMode(GL_MODELVIEW)

def draw_hud():
    lives_left = max(0, MAX_HITS - hit_count)
    level_name = 'EASY' if difficulty == 1 else 'MEDIUM' if difficulty == 2 else 'HARD'
    draw_text(18, 760, f"SCORE:{score:04d}   LEVEL:{difficulty}({level_name})   LIVES:{lives_left}")
    draw_text(18, 736, f"ENERGY:{energy:03d}")
    if umbrella_active:
        draw_text(840, 770, "â˜‚ UMBRELLA", GLUT_BITMAP_HELVETICA_18, (0.9, 0.9, 0.2))

# =========================
# Moon base and craters
# =========================
def init_craters():
    craters.clear()
    for _ in range(NUM_CRATERS):
        r = random.uniform(28, 70)
        ang = random.uniform(0, 2*math.pi)
        dist = random.uniform(80, BASE_RADIUS - r - 20)
        x = dist * math.cos(ang)
        y = dist * math.sin(ang)
        craters.append((x, y, r))

def draw_moon_base():
    # base disc (flat stylized)
    glColor3f(0.68, 0.68, 0.7)
    glBegin(GL_TRIANGLE_FAN)
    glVertex3f(0, 0, 0)
    for ang in range(0, 361, 4):
        a = math.radians(ang)
        glVertex3f(BASE_RADIUS * math.cos(a), BASE_RADIUS * math.sin(a), 0)
    glEnd()
    # craters
    for cx, cy, r in craters:
        glColor3f(0.28, 0.28, 0.33)
        glBegin(GL_TRIANGLE_FAN)
        glVertex3f(cx, cy, -0.5)
        for ang in range(0, 361, 6):
            a = math.radians(ang)
            glVertex3f(cx + r * math.cos(a), cy + r * math.sin(a), -0.5)
        glEnd()
        glColor3f(0.46, 0.46, 0.5)
        glBegin(GL_TRIANGLE_FAN)
        for ang in range(0, 361, 6):
            a = math.radians(ang)
            glVertex3f(cx + 0.62 * r * math.cos(a), cy + 0.62 * r * math.sin(a), -3.0)
        glEnd()
        glColor3f(0.78, 0.78, 0.82)
        glBegin(GL_LINE_LOOP)
        for ang in range(0, 361, 6):
            a = math.radians(ang)
            glVertex3f(cx + 0.7 * r * math.cos(a), cy + 0.7 * r * math.sin(a), 0.0)
        glEnd()

# =========================
# Player + umbrella + drawing
# =========================
def midpoint_circle(radius, cx, cy, z=20):
    x, y = 0, radius
    d = 1 - radius
    glBegin(GL_POINTS)
    while x <= y:
        glVertex3f(cx + x, cy + y, z)
        glVertex3f(cx - x, cy + y, z)
        glVertex3f(cx + y, cy + x, z)
        glVertex3f(cx - y, cy + x, z)
        if d < 0:
            d += 2*x + 3
        else:
            d += 2*(x - y) + 5
            y -= 1
        x += 1
    glEnd()

def draw_umbrella():
    if not umbrella_active: 
        return
    px, py, pz = player_pos
    glColor3f(0.85, 0.15, 0.2)
    midpoint_circle(30, px, py, 20)
    glBegin(GL_LINES)
    glVertex3f(px, py, 20)
    glVertex3f(px, py, -20)
    glEnd()

def draw_player():
    if first_person_mode and not game_over:
        return
    glPushMatrix()
    glTranslatef(player_pos[0], player_pos[1], 0)
    glRotatef(gun_angle, 0, 0, 1)

    # torso
    glColor3f(0.4, 0.65, 0.4)
    glPushMatrix()
    glTranslatef(0, 0, TORSO_H / 2.0)
    glScalef(TORSO_W, TORSO_D, TORSO_H)
    glutSolidCube(1)
    glPopMatrix()

    # head
    glColor3f(0.05, 0.05, 0.05)
    glPushMatrix()
    glTranslatef(0, 0, TORSO_H + HEAD_R)
    glutSolidSphere(HEAD_R, 20, 20)
    glPopMatrix()

    # shoulders & arms
    glColor3f(0.9, 0.8, 0.7)
    for side in (-1, 1):
        glPushMatrix()
        glTranslatef(0, side * (TORSO_D / 2.0 + SHOULDER_R * 0.3), TORSO_H * 0.74)
        glutSolidSphere(SHOULDER_R, 12, 12)
        glPopMatrix()

        glPushMatrix()
        glTranslatef(0, side * (TORSO_D / 2.0 + 1), TORSO_H * 0.74)
        glRotatef(90, 0, 1, 0)
        quad = gluNewQuadric()
        gluCylinder(quad, ARM_R, ARM_R, ARM_L, 12, 1)
        glPopMatrix()

    # legs
    glColor3f(0.05, 0.05, 0.85)
    for side in (-1, 1):
        glPushMatrix()
        glTranslatef(side * (TORSO_W * 0.22), 0, 0)
        quad = gluNewQuadric()
        gluCylinder(quad, LEG_R_TOP, LEG_R_BOT, LEG_L, 12, 1)
        glPopMatrix()

    draw_umbrella()
    glPopMatrix()

# =========================
# Stars (blinking)
# =========================
def draw_stars():
    glPointSize(2)
    glBegin(GL_POINTS)
    for s in stars:
        brightness = (math.sin(time.time() * 2.0 + s["phase"]) + 1.0) * 0.5
        glColor3f(brightness, brightness, brightness)
        glVertex3f(s["x"], s["y"], s["z"])
    glEnd()

# =========================
# Meteors: spawn, update, draw
# =========================
def meteor_params_for_difficulty(level):
    if level == 1: return (1.2, 2, 8.0, 6)
    if level == 2: return (0.8, 4, 12.0, 8)
    return (0.5, 6, 18.0, 12)

def spawn_meteor_wave():
    interval, count, speed, _ = meteor_params_for_difficulty(difficulty)
    for _ in range(count):
        ang = random.uniform(0, 2*math.pi)
        dist = random.uniform(20, BASE_RADIUS - 20)
        x = dist * math.cos(ang)
        y = dist * math.sin(ang)
        z = random.uniform(350, 650)
        vx = random.uniform(-0.8, 0.8)
        vy = random.uniform(-0.8, 0.8)
        vz = -max(1.5, speed * 0.25)
        r = random.uniform(14, 32) if difficulty == 1 else random.uniform(12, 28)
        meteors.append({
            "x": x, "y": y, "z": z,
            "vx": vx, "vy": vy, "vz": vz,
            "r": r,
            "is_hit": False,
            "hit_timer": 0.0
        })

def update_meteors_and_collisions():
    global meteors, lasers, score, hit_count, energy, game_over
    new_meteors = []
    new_lasers = list(lasers)

    for m in meteors:
        # advance if not in final vanish
        if not m["is_hit"]:
            m["x"] += m["vx"]
            m["y"] += m["vy"]
            m["z"] += m["vz"]
        else:
            m["hit_timer"] += FRAME_DT
            # allow a little movement during flicker
            m["x"] += m["vx"] * 0.2
            m["y"] += m["vy"] * 0.2
            m["z"] += m["vz"] * 0.2

        # remove if below ground
        if m["z"] < -10:
            continue

        # if meteor is already hit, remove after flicker_duration
        if m["is_hit"]:
            flicker_duration = 0.45
            if m["hit_timer"] >= flicker_duration:
                continue
            else:
                new_meteors.append(m)
                continue

        # collision with player (horizontal radius + z threshold)
        dx = m["x"] - player_pos[0]
        dy = m["y"] - player_pos[1]
        horiz = math.hypot(dx, dy)
        if horiz < (m["r"] + 12) and m["z"] <= 25:
            # player takes one life
            hit_count += 1
            energy -= 10
            score -= 5
            if score < 0: score = 0
            if hit_count >= MAX_HITS:
                game_over = True
            if energy <= 0:
                energy = 0
                game_over = True
            # meteor destroyed on impact
            continue

        # check collision with lasers
        hit_by_laser = False
        for l in list(new_lasers):
            dx = m["x"] - l["x"]; dy = m["y"] - l["y"]; dz = m["z"] - l["z"]
            dist3 = math.sqrt(dx*dx + dy*dy + dz*dz)
            if dist3 <= (m["r"] + 2.5):
                # mark meteor as hit (flicker)
                m["is_hit"] = True
                m["hit_timer"] = 0.0
                score += LASER_SCORE
                try:
                    new_lasers.remove(l)
                except ValueError:
                    pass
                hit_by_laser = True
                break
        if not hit_by_laser:
            new_meteors.append(m)

    meteors = new_meteors
    lasers = new_lasers

def draw_meteors():
    for m in meteors:
        glPushMatrix()
        glTranslatef(m["x"], m["y"], m["z"])
        if m["is_hit"]:
            # flicker
            if int(m["hit_timer"] * 20) % 2 == 0:
                glColor3f(1.0, 0.9, 0.5)
                glutSolidSphere(m["r"], 16, 16)
        else:
            glColor3f(1.0, 0.6, 0.1)
            glutSolidSphere(m["r"], 16, 16)
        glPopMatrix()

# =========================
# Lasers update/draw
# =========================
def update_lasers():
    global lasers
    kept = []
    step = LASER_SPEED * FRAME_DT
    ga_rad = math.radians(gun_angle)
    dx_step = math.cos(ga_rad) * step
    dy_step = math.sin(ga_rad) * step
    for l in lasers:
        l["x"] += dx_step
        l["y"] += dy_step
        l["z"] += step * 0.5
        l["life"] += FRAME_DT
        # keep laser alive only short time to avoid forever projectiles
        if l["life"] < 2.0 and abs(l["x"]) < 10000 and abs(l["y"]) < 10000:
            kept.append(l)
    lasers = kept

def draw_lasers():
    glLineWidth(2.0)
    glBegin(GL_LINES)
    for l in lasers:
        glColor3f(0.1, 1.0, 0.4)
        # draw a short bright beam in direction of travel
        glVertex3f(l["x"], l["y"], l["z"])
        glVertex3f(l["x"] + math.cos(math.radians(gun_angle)) * LASER_LENGTH,
                   l["y"] + math.sin(math.radians(gun_angle)) * LASER_LENGTH,
                   l["z"] + LASER_LENGTH * 0.2)
    glEnd()

# =========================
# Controls & camera
# =========================
def keyboardListener(key, x, y):
    global gun_angle, player_pos, umbrella_active, difficulty, lasers, last_laser_time, game_over
    if game_over and key != b'\x1b':
        return
    if key == b'a':     # rotate left
        gun_angle = (gun_angle + 6) % 360
    elif key == b'd':   # rotate right
        gun_angle = (gun_angle - 6) % 360
    elif key == b'w':   # forward relative to gun_angle
        nx = player_pos[0] + math.cos(math.radians(gun_angle)) * PLAYER_SPEED
        ny = player_pos[1] + math.sin(math.radians(gun_angle)) * PLAYER_SPEED
        if math.hypot(nx, ny) <= BASE_RADIUS - 18:
            player_pos[0], player_pos[1] = nx, ny
    elif key == b's':   # backward
        nx = player_pos[0] - math.cos(math.radians(gun_angle)) * PLAYER_SPEED
        ny = player_pos[1] - math.sin(math.radians(gun_angle)) * PLAYER_SPEED
        if math.hypot(nx, ny) <= BASE_RADIUS - 18:
            player_pos[0], player_pos[1] = nx, ny
    elif key == b'q':   # strafe left
        nx = player_pos[0] + math.cos(math.radians(gun_angle + 90)) * PLAYER_SPEED
        ny = player_pos[1] + math.sin(math.radians(gun_angle + 90)) * PLAYER_SPEED
        if math.hypot(nx, ny) <= BASE_RADIUS - 18:
            player_pos[0], player_pos[1] = nx, ny
    elif key == b'e':   # strafe right
        nx = player_pos[0] + math.cos(math.radians(gun_angle - 90)) * PLAYER_SPEED
        ny = player_pos[1] + math.sin(math.radians(gun_angle - 90)) * PLAYER_SPEED
        if math.hypot(nx, ny) <= BASE_RADIUS - 18:
            player_pos[0], player_pos[1] = nx, ny
    elif key == b'u':
        umbrella_active = not umbrella_active
    elif key in (b'1', b'2', b'3'):
        try:
            diff = int(key.decode('ascii'))
            if diff in (1, 2, 3):
                global difficulty
                difficulty = diff
        except:
            pass
    elif key == b' ':
        # fire laser
        now = time.time()
        if now - last_laser_time >= LASER_COOLDOWN:
            lasers.append({"x": player_pos[0], "y": player_pos[1], "z": player_pos[2] + TORSO_H * 0.72, "life": 0.0})
            last_laser_time = now
    elif key == b'\r' and game_over:
        restart()
    elif key == b'\x1b':
        glutLeaveMainLoop()

def specialKeyListener(key, x, y):
    global camera_angle, camera_height, camera_pos
    if key == GLUT_KEY_UP:
        camera_height = min(900, camera_height + 20)
    elif key == GLUT_KEY_DOWN:
        camera_height = max(120, camera_height - 20)
    elif key == GLUT_KEY_LEFT:
        camera_angle = (camera_angle + 4) % 360
    elif key == GLUT_KEY_RIGHT:
        camera_angle = (camera_angle - 4) % 360
    # update camera_pos
    dist = camera_radius
    camera_pos[0] = dist * math.cos(math.radians(camera_angle))
    camera_pos[1] = dist * math.sin(math.radians(camera_angle))
    camera_pos[2] = camera_height

# =========================
# Camera & rendering
# =========================
def setupCamera():
    glMatrixMode(GL_PROJECTION)
    glLoadIdentity()
    gluPerspective(110, 1.25, 0.1, 5000)
    glMatrixMode(GL_MODELVIEW)
    glLoadIdentity()
    x, y, z = camera_pos
    gluLookAt(x, y, z, 0, 0, 0, 0, 0, 1)

def draw_game_over():
    draw_text(340, 420, "GAME OVER - You Died!", GLUT_BITMAP_HELVETICA_18, (1, 0.3, 0.3))

def showScreen():
    glClear(GL_COLOR_BUFFER_BIT | GL_DEPTH_BUFFER_BIT)
    glLoadIdentity()
    setupCamera()
    # background elements
    draw_stars()
    draw_moon_base()
    # gameplay objects
    draw_meteors()
    draw_lasers()
    draw_player()
    draw_hud()
    if game_over:
        draw_game_over()
    glutSwapBuffers()

# =========================
# Main loop update
# =========================
def idle():
    global last_spawn_time
    if game_over:
        glutPostRedisplay()
        return
    interval, _, _, _ = meteor_params_for_difficulty(difficulty)
    now = time.time()
    if now - last_spawn_time >= interval:
        spawn_meteor_wave()
        last_spawn_time = now
    update_meteors_and_collisions()
    update_lasers()
    glutPostRedisplay()
    # keep framerate reasonable
    time.sleep(max(0.0, FRAME_DT - 0.002))

# =========================
# Restart and main
# =========================
def restart():
    global energy, score, game_over, meteors, lasers, player_pos, gun_angle, hit_count
    energy = 100; score = 0; game_over = False
    meteors = []; lasers = []
    player_pos = [0, 0, 20]; gun_angle = 55
    hit_count = 0

def main():
    glutInit()
    glutInitDisplayMode(GLUT_DOUBLE | GLUT_RGB | GLUT_DEPTH)
    glutInitWindowSize(1000, 800)
    glutInitWindowPosition(40, 40)
    glutCreateWindow(b"LUNARIS: The Last Outpost")
    glEnable(GL_DEPTH_TEST)
    glClearColor(0.02, 0.02, 0.04, 1)
    init_craters()
    glutDisplayFunc(showScreen)
    glutKeyboardFunc(keyboardListener)
    glutSpecialFunc(specialKeyListener)
    glutIdleFunc(idle)
    glutMainLoop()

if __name__ == "__main__":
    main()
